<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ocean Wave Simulation</title>
  <style>
    :root{
      --bg0:#071018;
      --bg1:#081a26;
      --panel: rgba(10, 22, 32, 0.52);
      --panel2: rgba(10, 22, 32, 0.30);
      --stroke: rgba(255,255,255,0.10);
      --text: rgba(240,250,255,0.92);
      --muted: rgba(240,250,255,0.70);
      --accent: rgba(120, 210, 255, 0.85);
      --shadow: rgba(0,0,0,0.35);
      --blur: 18px;
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 60% 10%, #0b2a3d 0%, var(--bg1) 40%, var(--bg0) 100%);
      color: var(--text);
      font-family: var(--sans);
      overflow: hidden;
    }

    /* Subtle “sky glow” overlay */
    .skyGlow{
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(900px 500px at 50% 0%, rgba(120,210,255,0.12), transparent 60%),
        radial-gradient(900px 700px at 10% 20%, rgba(180,130,255,0.06), transparent 70%),
        radial-gradient(800px 500px at 90% 30%, rgba(255,190,120,0.05), transparent 70%);
      mix-blend-mode: screen;
      opacity: 0.85;
    }

    canvas{
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .ui {
      position: fixed;
      top: 18px;
      left: 18px;
      right: 18px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      pointer-events: none; /* allow canvas interactions if desired */
    }

    .panel {
      pointer-events: auto;
      max-width: 540px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: 0 18px 40px var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      padding: 14px 14px 12px;
    }

    .header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      margin-bottom: 10px;
    }

    .title {
      font-size: 14px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(240,250,255,0.88);
    }

    .sub {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 12px;
    }

    .control {
      display: grid;
      gap: 6px;
      padding: 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .labelRow{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    label{
      font-size: 12px;
      color: rgba(240,250,255,0.82);
    }

    .value {
      font-size: 12px;
      font-family: var(--mono);
      color: rgba(200,240,255,0.88);
      opacity: 0.95;
    }

    input[type="range"]{
      width: 100%;
      accent-color: rgba(120,210,255,0.85);
    }

    .footerRow{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap:10px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.08);
    }

    .btns{
      display:flex;
      gap:8px;
      flex-wrap: wrap;
    }

    button{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(240,250,255,0.92);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 0.08s ease, background 0.2s ease, border-color 0.2s ease;
    }
    button:hover{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.16);
    }
    button:active{
      transform: translateY(1px);
    }

    .hint{
      font-size: 12px;
      color: rgba(240,250,255,0.65);
      line-height: 1.35;
    }

    /* Bottom-right mini readout */
    .readout{
      position: fixed;
      bottom: 18px;
      right: 18px;
      pointer-events: none;
      display: grid;
      gap: 6px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.09);
      background: rgba(10, 22, 32, 0.35);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 16px 32px rgba(0,0,0,0.28);
      max-width: 240px;
    }
    .readout .k{
      font-size: 11px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(240,250,255,0.62);
    }
    .readout .v{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(220,250,255,0.90);
    }

    @media (max-width: 720px){
      .grid{ grid-template-columns: 1fr; }
      .panel{ max-width: unset; }
      .readout{ display: none; }
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <div class="skyGlow"></div>

  <div class="ui" role="application" aria-label="Ocean Wave Simulation">
    <div class="panel">
      <div class="header">
        <div class="title">Ocean Wave Simulation</div>
        <div class="sub" id="status">Calm • 60 FPS target</div>
      </div>

      <div class="grid">
        <div class="control">
          <div class="labelRow">
            <label for="wind">Wind speed</label>
            <div class="value" id="windVal">12</div>
          </div>
          <input id="wind" type="range" min="0" max="30" step="1" value="12" />
        </div>

        <div class="control">
          <div class="labelRow">
            <label for="height">Wave height</label>
            <div class="value" id="heightVal">0.55</div>
          </div>
          <input id="height" type="range" min="0" max="1.25" step="0.01" value="0.55" />
        </div>

        <div class="control">
          <div class="labelRow">
            <label for="light">Lighting</label>
            <div class="value" id="lightVal">0.68</div>
          </div>
          <input id="light" type="range" min="0" max="1" step="0.01" value="0.68" />
        </div>

        <div class="control">
          <div class="labelRow">
            <label for="chop">Choppiness</label>
            <div class="value" id="chopVal">0.42</div>
          </div>
          <input id="chop" type="range" min="0" max="1" step="0.01" value="0.42" />
        </div>
      </div>

      <div class="footerRow">
        <div class="btns">
          <button id="presetCalm" type="button">Calm</button>
          <button id="presetBreeze" type="button">Breeze</button>
          <button id="presetStorm" type="button">Storm</button>
          <button id="pause" type="button">Pause</button>
        </div>
        <div class="hint">Drag sliders to shape the sea. (No WebGL—pure Canvas.)</div>
      </div>
    </div>
  </div>

  <div class="readout" aria-hidden="true">
    <div><div class="k">Wind</div><div class="v" id="rWind">—</div></div>
    <div><div class="k">Wave height</div><div class="v" id="rHeight">—</div></div>
    <div><div class="k">Lighting</div><div class="v" id="rLight">—</div></div>
  </div>

<script>
(() => {
  // --- Canvas setup ---
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize(){
    canvas.width  = Math.floor(window.innerWidth  * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // --- UI ---
  const $ = (id) => document.getElementById(id);
  const wind = $('wind'), height = $('height'), light = $('light'), chop = $('chop');
  const windVal = $('windVal'), heightVal = $('heightVal'), lightVal = $('lightVal'), chopVal = $('chopVal');
  const status = $('status');
  const rWind = $('rWind'), rHeight = $('rHeight'), rLight = $('rLight');

  const state = {
    wind: +wind.value,         // 0..30
    height: +height.value,     // 0..1.25
    light: +light.value,       // 0..1
    chop: +chop.value,         // 0..1
    paused: false
  };

  function syncUI(){
    windVal.textContent = `${state.wind}`;
    heightVal.textContent = state.height.toFixed(2);
    lightVal.textContent = state.light.toFixed(2);
    chopVal.textContent = state.chop.toFixed(2);

    rWind.textContent = `${state.wind} m/s (approx)`;
    rHeight.textContent = `${(state.height*2.2).toFixed(2)} m (visual)`;
    rLight.textContent = `${Math.round(state.light*100)}%`;

    // vibe label
    let vibe = 'Calm';
    if (state.wind > 18 || state.height > 0.95) vibe = 'Rough';
    else if (state.wind > 10 || state.height > 0.65) vibe = 'Breezy';
    status.textContent = `${vibe} • 60 FPS target`;
  }

  function bindSlider(el, key){
    el.addEventListener('input', () => {
      state[key] = +el.value;
      syncUI();
    }, { passive: true });
  }
  bindSlider(wind, 'wind');
  bindSlider(height, 'height');
  bindSlider(light, 'light');
  bindSlider(chop, 'chop');
  syncUI();

  // Presets
  function setPreset(p){
    state.wind = p.wind; state.height = p.height; state.light = p.light; state.chop = p.chop;
    wind.value = state.wind; height.value = state.height; light.value = state.light; chop.value = state.chop;
    syncUI();
  }
  $('presetCalm').addEventListener('click', () => setPreset({ wind: 6,  height: 0.42, light: 0.72, chop: 0.25 }));
  $('presetBreeze').addEventListener('click', () => setPreset({ wind: 14, height: 0.68, light: 0.66, chop: 0.45 }));
  $('presetStorm').addEventListener('click', () => setPreset({ wind: 26, height: 1.05, light: 0.52, chop: 0.70 }));

  const pauseBtn = $('pause');
  pauseBtn.addEventListener('click', () => {
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
  });

  // --- Wave model (multi-octave Gerstner-like field, 2D render) ---
  // We render the ocean as many horizontal "slices" (polylines) with shading,
  // displaced by a wave field. This gives parallax + realism without WebGL.

  function mulberry32(a){
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }
  const rand = mulberry32(2);

  // A small set of wave components; we scale their amplitude/speed via sliders.
  const components = Array.from({length: 9}, (_, i) => {
    // Directions biased toward rightward (wind direction) with slight spread.
    const ang = (rand()*0.55 - 0.275) + (i%3===0 ? 0.08 : 0);
    const dir = { x: Math.cos(ang), y: Math.sin(ang) };
    const wl = 120 + rand()*640;        // wavelength in px
    const k  = (Math.PI * 2) / wl;      // wave number
    const baseAmp = 6 + rand()*18;      // px
    const steep = 0.10 + rand()*0.20;   // base steepness
    const phase = rand()*Math.PI*2;
    return { dir, k, baseAmp, steep, phase };
  });

  function waveField(x, z, t, windSpeed, waveHeight, choppy){
    // z is "depth into screen" (0 near, 1 far). Use it to scale frequency.
    // Return displacement (dx, dy) and slope for shading.
    let dx = 0, dy = 0;
    let ddx = 0, ddy = 0; // derivatives for normal-ish shading
    const wind = windSpeed / 30;        // 0..1
    const H = waveHeight;              // 0..1.25
    const chop = choppy;               // 0..1

    // Let far waves be slightly smoother + higher frequency.
    const zFreq = 0.65 + 0.9 * z;
    const zAmp  = 0.55 + 0.85 * (1 - z);

    for (let i=0;i<components.length;i++){
      const c = components[i];
      // speed grows with wind; longer waves faster
      const omega = Math.sqrt(9.81 * c.k) * 22 * (0.35 + 0.95*wind);
      const A = c.baseAmp * H * zAmp * (0.55 + 0.65*wind);
      const Q = (c.steep * (0.35 + 0.85*chop)) / (1 + c.k*A*0.08);

      const dot = (c.dir.x * x + c.dir.y * (z*900)) * c.k * zFreq;
      const ph = dot + omega*t + c.phase;

      const s = Math.sin(ph);
      const cs = Math.cos(ph);

      // Gerstner horizontal displacement (chop) and vertical displacement.
      dx += Q * A * c.dir.x * cs;
      dy += A * s;

      // approximate derivative w.r.t x for shading
      const dphdx = c.dir.x * c.k * zFreq;
      ddx += -Q * A * c.dir.x * s * dphdx;
      ddy += A * cs * dphdx;
    }
    return { dx, dy, ddx, ddy };
  }

  // --- Rendering helpers ---
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function drawSky(w, h, lighting){
    // Gradient sky + subtle horizon glow. Lighting shifts brightness and hue.
    const L = lighting;
    const top = `rgba(${Math.round(8 + 12*L)}, ${Math.round(22 + 40*L)}, ${Math.round(34 + 60*L)}, 1)`;
    const mid = `rgba(${Math.round(8 + 14*L)}, ${Math.round(24 + 38*L)}, ${Math.round(44 + 66*L)}, 1)`;
    const low = `rgba(${Math.round(5 + 8*L)},  ${Math.round(14 + 20*L)}, ${Math.round(22 + 28*L)}, 1)`;

    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0.00, top);
    g.addColorStop(0.55, mid);
    g.addColorStop(1.00, low);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // Horizon haze
    const hz = ctx.createLinearGradient(0, h*0.45, 0, h*0.72);
    hz.addColorStop(0, `rgba(170,220,255,${0.10 + 0.08*L})`);
    hz.addColorStop(1, `rgba(170,220,255,0)`);
    ctx.fillStyle = hz;
    ctx.fillRect(0, h*0.45, w, h*0.3);
  }

  function drawVignette(w,h){
    const r = Math.max(w,h)*0.62;
    const g = ctx.createRadialGradient(w*0.55, h*0.25, r*0.15, w*0.5, h*0.35, r);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.45)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawOcean(t){
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Split view: sky above, ocean below with a soft horizon.
    const horizon = h * 0.42;

    // Lighting parameter influences contrast and specular strength.
    const L = state.light;

    drawSky(w, h, L);

    // Ocean base gradient
    const seaG = ctx.createLinearGradient(0, horizon, 0, h);
    seaG.addColorStop(0.00, `rgba(${Math.round(12 + 8*L)}, ${Math.round(46 + 16*L)}, ${Math.round(66 + 18*L)}, 1)`);
    seaG.addColorStop(0.55, `rgba(${Math.round(8 + 6*L)}, ${Math.round(28 + 10*L)}, ${Math.round(46 + 16*L)}, 1)`);
    seaG.addColorStop(1.00, `rgba(${Math.round(5 + 4*L)}, ${Math.round(18 + 8*L)}, ${Math.round(30 + 10*L)}, 1)`);
    ctx.fillStyle = seaG;
    ctx.fillRect(0, horizon, w, h - horizon);

    // Surface rendering as many "depth lines"
    const lines = Math.floor(85 + 80*clamp(state.wind/30,0,1));   // more wind -> more texture
    const points = Math.floor(140 + w/10);                        // polyline resolution
    const windN = state.wind;
    const H = state.height;
    const chopN = state.chop;

    // Sun / light direction (fixed, slight offset)
    const lightDir = { x: -0.65, y: 0.45 }; // used for highlight bias
    const specStrength = 0.18 + 0.48*L;
    const foamStrength = 0.05 + 0.28*clamp((windN/30) * (H/1.25), 0, 1);

    // Draw from far to near for proper overlap
    for (let i=0;i<lines;i++){
      const z = i/(lines-1);              // 0 far -> 1 near (we'll invert where needed)
      const zFar = 1 - z;                 // 1 far, 0 near
      const yBase = horizon + (z*z) * (h - horizon) * 0.98; // ease-in depth spacing

      // Thicker/stronger near
      const thickness = 0.6 + 1.4*z;
      ctx.lineWidth = thickness;

      // Color shifts with depth and lighting
      const depthDark = 0.22 + 0.55*z;
      const alpha = 0.08 + 0.26*z;
      const r = Math.round(18 + 16*L - 6*depthDark);
      const g = Math.round(80 + 35*L - 18*depthDark);
      const b = Math.round(112 + 30*L - 18*depthDark);

      // We'll build a path and then stroke it with a gradient-ish alpha by segment highlights.
      // For performance, stroke once but vary composite highlights in a second pass.
      ctx.beginPath();

      // Precompute x range a bit wider to avoid edge gaps under displacement
      const xMin = -40, xMax = w + 40;
      const dxStep = (xMax - xMin) / (points - 1);

      // For highlight pass we store some values (small arrays)
      const xs = new Float32Array(points);
      const ys = new Float32Array(points);
      const br = new Float32Array(points); // brightness for specular / foam

      for (let p=0;p<points;p++){
        const x = xMin + p*dxStep;
        // time scaling: wind drives animation speed
        const tt = t * (0.55 + 1.35*(windN/30));
        const wf = waveField(x, zFar, tt, windN, H, chopN);

        // Perspective-ish: far waves smaller, near larger
        const ampPerspective = 0.25 + 1.05*z;
        const y = yBase + wf.dy * ampPerspective;

        // Horizontal chop gives small lateral drift for texture
        const xx = x + wf.dx * (0.18 + 0.55*z);

        // Shading from slope (ddy ~ dy/dx). Create a pseudo-normal.
        const slope = wf.ddy;
        const nx = -slope;
        const ny = 1.0;
        const invLen = 1/Math.hypot(nx, ny);
        const nxx = nx*invLen, nyy = ny*invLen;

        // Specular-ish: brighter when normal faces "light"
        const ndotl = clamp(nxx*lightDir.x + nyy*lightDir.y, -1, 1);
        const spec = Math.pow(clamp((ndotl + 0.35), 0, 1), 7) * specStrength;

        // Foam: peaks when curvature/slope indicates crest + wind is high
        const crest = clamp(Math.abs(wf.ddy) * 0.9 + Math.abs(wf.ddx) * 0.6, 0, 2);
        const foam = Math.pow(clamp(crest - 0.55, 0, 1), 1.3) * foamStrength;

        xs[p] = xx;
        ys[p] = y;
        br[p] = clamp(spec + foam, 0, 1);

        if (p === 0) ctx.moveTo(xx, y);
        else ctx.lineTo(xx, y);
      }

      // Base stroke
      ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
      ctx.stroke();

      // Highlight pass: add light glints / foam with additive blend
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.beginPath();
      for (let p=0;p<points;p++){
        const intensity = br[p];
        if (intensity < 0.10) continue;
        // small segments to avoid huge paths
        const x0 = xs[p], y0 = ys[p];
        ctx.moveTo(x0, y0);
        ctx.lineTo(x0 + 0.01, y0); // tiny stroke point
      }
      const highlightAlpha = 0.10 + 0.42*L;
      ctx.strokeStyle = `rgba(210,240,255,${highlightAlpha})`;
      ctx.lineWidth = thickness * (0.45 + 0.55*z);
      ctx.stroke();
      ctx.restore();
    }

    // Soft horizon line to blend sea/sky
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const hg = ctx.createLinearGradient(0, horizon-18, 0, horizon+40);
    hg.addColorStop(0, `rgba(220,245,255,${0.10 + 0.10*L})`);
    hg.addColorStop(1, 'rgba(220,245,255,0)');
    ctx.fillStyle = hg;
    ctx.fillRect(0, horizon-20, w, 70);
    ctx.restore();

    drawVignette(w,h);
  }

  // --- Animation loop ---
  let last = performance.now();
  let acc = 0;
  let fps = 60;

  function tick(now){
    const dt = (now - last) / 1000;
    last = now;
    if (!state.paused) acc += dt;

    // Lightweight FPS estimate for the status line
    fps = fps*0.92 + (1/Math.max(dt, 1e-6))*0.08;

    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    drawOcean(acc);

    // Update status occasionally
    if (Math.random() < 0.05){
      const vibe = (state.wind > 18 || state.height > 0.95) ? 'Rough' : (state.wind > 10 || state.height > 0.65) ? 'Breezy' : 'Calm';
      status.textContent = `${vibe} • ${Math.round(fps)} FPS`;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
